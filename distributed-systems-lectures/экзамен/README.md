# Вопросы к экзамену

### 1. Что такое микросервисная архитектура? Плюсы и минусы по сравнению с монолитом.
&emsp;&emsp;&emsp;&emsp;Микросервисная архитектура — это подход к разработке программного обеспечения, при котором приложение состоит из множества небольших, независимых сервисов, каждый из которых выполняет свою конкретную задачу. Эти сервисы взаимодействуют друг с другом через API и могут быть развернуты и масштабированы независимо.
- Плюсы микросервисной архитектуры:
    - Масштабируемость.
    - Гибкость (Разнообразие технологий).
    - Устойчивость.
    - Быстрая доставка.
    - Упрощение разработки.
- Минусы микросервисной архитектуры:
    - Система должна работать быстро, т.к. теперь ко времени выполнения самих операций требуется прибавлять время взаимодействия по сети.
    - Нужно иметь хорошую систему деплоя и развертывания новых виртуальных машин, т.к. количество сервисов будет расти и настройка всего окружения вручную будет проблематична.
    - Требуется хорошее описание внешнего API.
    - С появлением большого количество сетевого трафика накладывается большая ответственность на сеть и отказоустойчивость оборудования.
    - В связи с этим, нужно при проектировании программы обязательно обрабатывать недоступность и ошибки от внешней системы.
    - Часто становится очень трудно разбить систему на сервисы из-за сильной связанности данных.
### 2. Критерии качества микросервисной архитектуры: слабая связность и сопряженность.
&emsp;&emsp;&emsp;&emsp;Слабая связность означает, что сервисы должны быть максимально независимыми друг от друга. Это позволяет изменять и масштабировать каждый сервис отдельно без влияния на другие части системы. Для достижения слабой связности рекомендуется использовать четкие API для взаимодействия между сервисами.
- Связанность содержимого (один модуль изменяет или полагается на внутренние особенности другого модуля).
- Связанность через общее (два модуля работают с общими данными).
- Связанность через внешнее (два модуля используют навязанный извне формат данных, протокол связи и т.д.).
- Связанность по управлению (один модуль управляет поведением другого).
- Связанность по структурированным данным (Модули используют одну и ту же структуру, но каждый использует только ее части).
- Связанность через данных (модули совместно используют данные, например, через параметры).
- Связанность по сообщениям (модули общаются только через передачу параметров или сообщений).
- Отсутствие связанности

&emsp;&emsp;&emsp;&emsp;Сопряженность характеризует то, насколько хорошо все методы класса или все фрагменты метода соответствуют главной цели, — иначе говоря, насколько сфокусирован класс. Считается, что объект (подсистема) обладает высокой сопряженностью (High Cohesion), если его обязанности хорошо согласованы между собой и он не выполняет огромных объемов работы.
- Случайная (Coincidental Cohesion) – части модуля сгруппированы случайным образом, единственное, что их объединяет — сам модуль.
- Логическая (Logical Cohesion) – части модуля логически относятся к одной проблеме, при этом части могут различаться по своей природе.
- Временная (Temporal Cohesion) – части модуля обычно используются в программе в одно время, рядом.
- Процедурная (Procedural Cohesion) – части модуля всегда используются в определенном порядке.
- По взаимодействию (Communication Cohesion) – части модуля работают над одним и теми же данными.
- По последовательности действий (Sequential Cohesion) – результат работы одной части модуля является исходными данными для другой.
- Функциональная (Functional Cohesion) – части модуля направлены на решение одной четкой задачи, за которую отвечает модуль.
![types](../decompose_into_microservices/images/Cohesion%20Types.png)
### 3. Проектирование микросервисов: декомпозиция по бизнес возможностям и Domain Driven Design. Что такое Bounded Context и чем он отличается от бизнес-сущности.
### 4. Маршрутизация в сети интернет.
### 5. Протокол TCP. Гарантия доставки. Flow Control и Congestion Control.
### 6. Отказоустойчивость на сетевом уровне.
### 7. Протокол HTTP. HTTPS. HTTP/2.
### 8. Угрозы в сети. DDoS, XSS, CSRF, Man-In-The-Middle. Что такое CORS?
### 9. OAuth2, OpenID Connect, JWT, JWKs.
### 10. Масштабирование и балансировка back-end’ов.
### 11. Кэширование.
### 12. Отказоустойчивость при межсервисных вызовах. Причины отказов в обслуживании.
### 13. RESTful. Пример.
### 14. Асинхронное взаимодействие сервисов. Идемпотентность запросов.
### 15. Очереди. At most once, at least once политики доставки.
### 16. Теорема CAP.
### 17. Протокол RAFT.
### 18. Протокол PAXOS.
### 19. Event Driven Architecture.
### 20. Оркеструемая и хореографическая SAGA.
### 21. Транзакции. ACID. Оптимистичная и пессимистичные блокировки.
### 22. Write ahead log. Связь с транзакциями.
### 23. RAID. Репликация.
### 24. Шардирование и партиционирование. Решардинг.
### 25. Service Discovery. Балансировка запросов: Client Side и Server Side Load balancing.
### 26. Gateway API. Зачем нужен, какие проблемы решает.
### 27. Паттерн Circuit Breaker.
### 28. Хореографическая и оркестрируемая SAGA.
### 29. Docker. Docker Compose. Сетевое взаимодействие между контейнерами и с host–машиной.
### 30. Что такое оркестрация сервисов, зачем нужен k8s.
### 31. Типы сущностей в K8S, зачем они нужны.
### 32. Пирамида тестирования. Зачем нужны unit тесты и как их правильно писать.